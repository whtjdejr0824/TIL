## 3. 연산자

```c++
/*
사칙연산자 : +, -, *, /, %(나머지 연산자)
관계연산자 : 값 vs 값을 연산하여 참/거짓으로 결과를 반환.(>, >=, <=, <, ==, !=)
논리연산자 ; 참/거짓 vs 참/거짓을 연산하여 최종적으로 참/거짓의 결과를 반환
AND(&&), OR(||)(Shift +\), NOT(!)
A  B  AND OR
0  0   0   0
1  0   0   1
0  1   0   1
1  1   1   1

A  NOT
0   1
1   0

진수 : 2진수, 8진수, 10진수, 16진수
2진수 : 0 ~ 1 // 8진수 : 0 ~ 7 // 10진수 : 0 ~ 9 // 16진수 : 0 ~ 9 / 10~15 a~f
진수들은 서로 다른 진수로 변환이 가능하다.
ex)87을 2진수, 16진수로 변환
2진수 : 
87/2 = 43 ... 1
43/2 = 21 ... 1
21/2 = 10 ... 1
10/2 = 5  ... 0
 5/2 = 2  ... 1
 2/2 = 1  ... 0
 가장 마지막에 나온 몫부터 역순으로 나머지값들은 읽는다.
 1010111 이 된다.
 
 16진수
 10진수로 바로 변환하는 것보다 2진수로 변환 후에 16진수로 하는 것이 쉽다.
 1010111을 오른쪽부터 4자기씩 끊어서 계산
 0101 0111
 8421 8421
 
 2진수가 1인 부분의 값들을 더한다.
 16진수 57(4+1,4+2+1)이 된다.
 
비트단위 논리연산자 : 2진수 단위의 연산을 한다. 값 대 값을 연산하여 값으로 나온다.
종류 : AND(&), OR(|), NOT(~), XOR(^)
A  B  XOR
0  0  0  
1  0  1
0  1  1
1  1  0

ex) 87 & 53 = 21 
87 : 1010111
53 : 0110101

먼저 위예시처럼 2진수로 변환 후, 2진수 각 자리별로 논리연산을 실행한다.
=AND(&)이므로 0010101이 나온다
10진수로 변환하면
=21

*/

cout << "10 < 20 = " << (10 < 20) << endl; //1 or True
cout << "10 > 20 = " << (10 > 20) << endl; //0 or False

cout << "숫자를 입력하세요 : ";
cin >> NUmber;
cout <<"10 ~ 20 = " << (10 <= Number && Number <= 20) << endl;

cout << "87 & 53 = " << (87 & 53) << endl;

#include <iostream>

using namespace std;

int main()
{
    // 상수 : 변하지 않는 수. 값을 한번 지정해놓으면 바꿀 수 없다.
    // 상수는 선언과 동시에 값을 지정해두어야 한다.
    const int iAttack = 0x00000001;   //    1
    const int iArmor = 0x00000002;    //   10
    const int iHP = 0x00000004;       //  100
    const int iMP = 0x00000008;       // 1000
    const int iCritical = 0x00000010; //10000
    
    //001 | 100 = 00101 | 10000 = 10101
    int iBuf = iAttack | iHP | iCritical;
    
    // 연산자 축약형 : 연산자를 줄여서 사용할 수 있다.
    // 아래를 풀어서 쓰면 iBuf = iBuf ^ iHP;
    // 10101 ^ 00100 = 10001
    iBuf ^= iHP;
    
    // 10001 ^ 00100 = 10101
    iBuf ^= iHP;
    
    // 10101 & 00001 = 1
    cout << "Attack : " << (iBuf & iAttack) << endl;
    // 10101 & 00010 = 0
    cout << "Armor : " << (iBuf & iArmor) << endl;
    cout << "HP : " << (iBuf & iHP) << endl;
    cout << "MP : " << (iBuf & iMP) << endl;
    cout << "Critial : " << (iBuf & iCritical) << endl;
    
    /*
    쉬프츠 연산자 : <<,>> 값 대 값을 연산하여 값으로 나오게 된다.
    이 연산자 또한 이진수 단위의 연산을 하게 된다.
    20 << 2 = 80
    20 << 3 = 160
    20 << 4 = 320
    20을 2진수로 변환한다.
    1010000
    10100000
    101000000
    
    20 >> 2 = 5
    20 >> 3 = 2
    101
    10
    */
    int iHigh = 187;
    int iLow = 13560;
    
    int iNumber = iHigh;
    iNumber = ihigh;
    
    // iNumber에는 187이 들어가있다. 이 값을 <-이 방향으로 16비트 이동시키면
    // 상위 16비트에 값이 들어가게 된다.
    iNumber <<=16;
    
    // 하위 16비트를 채운다.
    iNumber |= iLow;
    
    // High 값을 출력한다.
    cout << "High : " << (iNumber >> 16) << endl;
    cout << "Low : " << (iNumber & 0x0000ffff) << endl;
    
    // 증감연산자 : ++, --가 있다. 1증가, 1감소이다.
    iNumber = 0;
    
    // 전치
    ++iNumber;
    
    // 후치
    iNumber++;
    
    cout << ++iNumber << endl;
    cout << iNumber++ << endl;
    cout << iNumber << endl;
    
    return 0;
}

```

