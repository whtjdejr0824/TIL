# 스코프 함수

람다 함수의 특별한 케이스

1. 람다함수도 여러 구문의 사용이 가능

```kotlin
val calculate:(Int, Int) -> Int = {a, b ->
    println(a)
    println(b)
    a+b
} // *여기서는 마지막 구문인 a+b의 값을 Int로 반환함
```



2. 람다함수에 패러미터가 없이 사용 가능 

   -> 실행할 구문들만 나열하면 됨.

   `val a: -> Unit = {println("패러미터가 없어요")}`

3. 패러미터가 하나뿐이라면 it사용

​         -> 패러미터가 여러개라면 람다함수 내에서 패러미터 이름을 일일이 작성

​        `val c: (String) -> Unit = {println("$it 람다함수")}`



#### 스코프함수

함수형 언어의 특징을 좀 더 편리하게 사용할 수 있도록 기본 제공하는 함수들

클래스에서 생성한 인스턴스를 scope함수에 전달하면, "인스턴스의 속성이나 함수를 좀 더 깔끔하게 불러 쓸 수 있음"

apply : 인스턴스를 생성한 후 변수에 담기 전에 '초기화 과정'을 수행할 때 많이 쓰임

```kotlin
fun main() {
    
    var price = 5000 // run함수가 인스턴스 내의 price속성보다 run이 속해있는 'main함수'의 price 변수를 우선시하고 있기 때문
    
    var a = Book("디모의 코틀린", 10000).apply { //apply와 같은 스코프 함수를 사용하면, main함수와 '별도의 scope'에서 인스턴스의 변수와 함수를 조작하므로 코드가 깔끔해진다는 장점이 있음
        name = "[초특가]" + name
        discount()
    }
    //a.name = "[초특가]"+a.name
    //a.discount()
    
    a.run {
        println("상품명 : ${name}, 가격: ${price}원")
    }
    
    a.let {
        println("상품명: ${it.name}, 가격: ${it.price}원")
    } // apply 역시 같은 경우가 있다면, 'also'로 대체하여 사용하면 됨.
    
}

class Book(var name: String, var price: Int) {
    fun discount() {
        price -= 2000
    }
}
```



run : apply처럼 run스코프 안에서 참조연산자를 사용하지 않아도 된다는 점은 같지만, 일반 람다함수처럼 인스턴스 대신 마지막 구문의 결과값을 반환한다는 차이점이 있음

```kotlin
var b = a.run {
    println(a.price)
    a.name
    //*이렇게 쓰면 가격은 출력하지만, 마지막 구문인 이름은 반환하여 b라는 변수에 할당됨
}
```

따라서, 이미 인스턴스가 만들어진 후에 인스턴스의 함수나 속성을 scope 내에서 사용해야 할 때, 유용함.



with : run과 '동일한 기능'을 가지지만, 단지 인스턴스를 참조연산자 대신 패러미터로 받는다는 차이일 뿐

`a.run{...}` / `with(a){...}`



처리가 끝나면 인스턴스를 반환,

`apply` / `also`

처리가 끝나면 최종값을 반환

`run` / `let`

한가지 공통적인 '차이점'이 있음.

apply와 run이 참조연산자 없이 인스턴스의 변수와 함수를 사용할 수 있었다면,

also와 let은 마치 패러미터로 인스턴스를 넘긴것처럼 it을 통해서 인스턴스를 사용할 수 있음



also와 let은 패러미터를 통헤 인스턴스를 사용하는 과정을 거치는 이유

-> 같은 이름의 변수나 함수가 'scope 바깥에 중복'되어 있는 경우에 혼란을 방지하기 위해서



스코프 함수는 인스턴스의 속성이나 함수를 scope 내에서 깔끔하게 분리하여 사용할 수 있다는 점 때문에 코드의 가독성을 향상시킨다는 장점이 있다는 것을 기억.