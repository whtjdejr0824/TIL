# 비트연산

정수형 변수를 10진법 대신에, 2진법인 비트단위로 연산할 수 있는 기능

학술적인 부분에서는 실제 10진법의 결과와 비교하는 식으로 가르쳐 주지만, 

실무에서 비트연산은 거의 계산에는 사용하지 않으며(*2진법을 이용한 연산 최적화가 필요하다면 컴파일러의 기능을 사용하는 경우가 대부분), 

정수형의 값을 비트단위로 나누어 데이터를 좀 더 작은 단위로 담아 경제성을 높이기 위한 용도로 사용됨

주로 플래그 값*(여러개의 상태값을 0과 1로 담는 방법)을 처리하거나 네트워크 등에서 프로토콜의 데이터 양을 줄이기 위해 자주 사용됨.

코틀린은 모든 정수형이 부호를 포함하므로 최상위 비트는 0이면 양수, 1이면 음수인 부호비트로 사용하기 때문에 데이터를 담지 않는 것이 좋음.



#### 비트를 밀어주는 bitwise shife operators

부호비트를 제외한 모든 비트를 좌측으로 밀어주는 기능(shl(shift left))

부호비트를 제외한 모든 비트를 우측으로 밀어주는 기능(shr(shift right))

부호비트를 포함하여 모든 비트를 우측으로 밀어주는 기능(ushl(unsigned shift left))



#### 비트를 조작하는 bitwise operators

`1010 and 0110`-> 결과값`0010`(비트가 둘다 1인 자리만 1로 반환함)

`1010 or 0110` -> 결과값 `1110`(비트가 둘중 하나라도 1인 자리는 1로 반환함)

`1010 xor 0110` -> 결과값 `1100`(비트가 같은 자리는 0, 다른 자리는 1로 반환함)



and 연산자는 그 특성을 이용하여 두 가지 기능으로 사용함

 비트를 확인하는방법

ex) `0110`(원본) and `0100`(비교값) ->`0100`(아래서 세번째 비트의 값을 알 수 있음)

비트의 clear하는 방법

ex) `0110`(원본) and `1100`(비교값) ->`0100`(아래 두 개의 비트를 0으로 만듦)



or 연산자는 반대로 비트의 set 연산, 즉 비트 값을 1로 설정하고 싶을 때 사용함

ex) `0110`(원본) or `1100`(비교값) ->`1110`



xor 연산자

비트들이 같은지 비교하는 방법

ex) `0110`(원본) xor `1100`(비교값) ->`1010`



#### 비트를 반전하는 inv()